import java.nio.file.Paths
import java.nio.file.Files
import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.*

apply plugin: 'ch.so.agi.gretl'
apply plugin: 'org.hidetake.ssh'

defaultTasks 'geoDoppelteSchemas'

/*
SFTP mit ssh-Plugin, siehe:
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/operation/SftpOperations.groovy
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/session/transfer/get/Sftp.groovy
*/

/*
Mit den Verzeichnissen ist es so ne Sache. Erschwert durch Docker. Betrifft 
die relativen Verzeichnisangaben. "." ist glaub in build.gradle was anderes als
in DuckDB. Darum wohl eher absolute Pfade verwenden. Ganz robust wäre es,
wenn man DuckDB den absoluten Pfad als SqlParameter übergeben würde.
*/

def outputFolder = "/tmp/qmbetrieb/"
def pathToOutputFolder = Files.createDirectories(Paths.get(outputFolder)).toFile().getAbsolutePath()

def dbUriDuckDB = 'jdbc:duckdb:./mytemp.duckdb'

def dbHostPub = dbUriPub.substring(dbUriPub.indexOf("//") + 2, dbUriPub.lastIndexOf("/"))
def dbDatabasePub = dbUriPub.substring(dbUriPub.lastIndexOf("/") + 1)
def dbConnectionStringPub = "'dbname=$dbDatabasePub user=$dbUserPub password=$dbPwdPub host=$dbHostPub'"

def dbHostEdit = dbUriEdit.substring(dbUriPub.indexOf("//") + 2, dbUriEdit.lastIndexOf("/"))
def dbDatabaseEdit = dbUriEdit.substring(dbUriEdit.lastIndexOf("/") + 1)
def dbConnectionStringEdit = "'dbname=$dbDatabaseEdit user=$dbUserEdit password=$dbPwdEdit host=$dbHostEdit'"

def dbHostSimi = dbUriSimi.substring(dbUriSimi.indexOf("//") + 2, dbUriSimi.lastIndexOf("/"))
def dbDatabaseSimi = dbUriSimi.substring(dbUriSimi.lastIndexOf("/") + 1)
def dbConnectionStringSimi = "'dbname=$dbDatabaseSimi user=$dbUserSimi password=$dbPwdSimi host=$dbHostSimi'"

ssh.settings {
    knownHosts = allowAnyHosts
}

remotes {
    sftpServer {
        host = sftpUrlSogis
        user = sftpUserSogis
        password = sftpPwdSogis
    }
}

//-----------

tasks.register('geoDoppelteSchemas', SqlExecutor) {
    database = [dbUriDuckDB, "", ""] // mit GRETL 3.1 nicht mehr nötig.
    sqlFiles = ["geo_doppelte_schemas.sql"]
    sqlParameters = [
        connectionStringPub : dbConnectionStringPub as String,
        connectionStringEdit : dbConnectionStringEdit as String
        ]
}

//-----------

tasks.register('simiSchemaOhneTabelle', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_schema_ohne_tabelle.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('simiRasterOhneDatesetView', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_raster_ohne_datasetview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('simiTableOhneTableView', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_table_ohne_tableview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('listSftpDirectories') {
    doLast {
        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def dirs = ls("./gretl")
                        .findAll({ !(it.filename in ['.', '..']) 
                            && !it.filename.startsWith('.') 
                            && !it.filename.startsWith('robots')
                            && !it.filename.startsWith('nutzungsbedingungen')})
                        .collect({ it.filename }).sort()

                    File lstFile = new File('/tmp/sftpDirectoriesList.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        dirs.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('diffKennungSimiDatenabgabe', SqlExecutor) {
    dependsOn 'listSftpDirectories'
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["diff_kennung_simi_datenabgabe.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('relationalThemePublicationCsv', SqlExecutor) {
    description 'Schreibt all vorhandenen Edit-Modell-Themenpublikationen (aka relational) in eine CSV-Datei.'
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["relational_theme_publication_csv.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('superflousPublicationFormatsCsv') {
    description 'Durchsucht anhand der CSV-Datei die Ordner nach shp, gpkg und dxf-Dateien und schreibt das Thema in eine CSV-Datei falls gefunden werden.'
    dependsOn 'relationalThemePublicationCsv'
    doLast {
        def themePublications = new File('/tmp/relational_theme_publication_csv.csv').text.readLines()
        //println themePublications

        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def themesWithSuperflousFormats = []
                    themePublications.each { themeDir ->
                        def files = ls("./gretl/$themeDir/aktuell")
                            .findAll({ !(it.filename in ['.', '..', 'meta'])
                                && (
                                    it.filename.contains('xtf')
                                    || it.filename.contains('shp')
                                    || it.filename.contains('dxf')
                                )
                            })
                            .collect({ it.filename }).sort()

                        if (files.size() > 0) {
                            themesWithSuperflousFormats.add(themeDir)
                        }
                    }
                    File lstFile = new File('/tmp/superflous_publication_formats.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        themesWithSuperflousFormats.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('relationalThemePublicationXlsx', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'superflousPublicationFormatsCsv'
    csvFile = file("/tmp/superflous_publication_formats.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputDir = file(outputFolder);
}

//-----------



