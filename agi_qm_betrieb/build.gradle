import java.nio.file.Paths
import java.nio.file.Files
import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.*

apply plugin: 'ch.so.agi.gretl'
apply plugin: 'org.hidetake.ssh'

defaultTasks 'uploadToExoscale'

/*
SFTP mit ssh-Plugin, siehe:
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/operation/SftpOperations.groovy
- https://github.com/int128/groovy-ssh/blob/77ac597/core/src/main/groovy/org/hidetake/groovy/ssh/session/transfer/get/Sftp.groovy
*/

/*
Mit den Verzeichnissen ist es so ne Sache. Erschwert durch Docker. Betrifft 
die relativen Verzeichnisangaben. "." ist glaub in build.gradle was anderes als
in DuckDB. Darum wohl eher absolute Pfade verwenden. Ganz robust wäre es,
wenn man DuckDB den absoluten Pfad als SqlParameter übergeben würde.
*/

def outputFolder = "/tmp/qmbetrieb/"
def pathToOutputFolder = Files.createDirectories(Paths.get(outputFolder)).toFile().getAbsolutePath()

def dbUriDuckDB = 'jdbc:duckdb:/tmp/mytemp.duckdb'

def outputResultDB = Paths.get(outputFolder, "qmbetrieb.duckdb").toFile()
def dbUriResultDB = "jdbc:duckdb:$outputResultDB"

def dbHostPub = dbUriPub.substring(dbUriPub.indexOf("//") + 2, dbUriPub.lastIndexOf("/"))
def dbDatabasePub = dbUriPub.substring(dbUriPub.lastIndexOf("/") + 1)
def dbConnectionStringPub = "'dbname=$dbDatabasePub user=$dbUserPub password=$dbPwdPub host=$dbHostPub'"

def dbHostEdit = dbUriEdit.substring(dbUriPub.indexOf("//") + 2, dbUriEdit.lastIndexOf("/"))
def dbDatabaseEdit = dbUriEdit.substring(dbUriEdit.lastIndexOf("/") + 1)
def dbConnectionStringEdit = "'dbname=$dbDatabaseEdit user=$dbUserEdit password=$dbPwdEdit host=$dbHostEdit'"

def dbHostSimi = dbUriSimi.substring(dbUriSimi.indexOf("//") + 2, dbUriSimi.lastIndexOf("/"))
def dbDatabaseSimi = dbUriSimi.substring(dbUriSimi.lastIndexOf("/") + 1)
def dbConnectionStringSimi = "'dbname=$dbDatabaseSimi user=$dbUserSimi password=$dbPwdSimi host=$dbHostSimi'"

ssh.settings {
    knownHosts = allowAnyHosts
}

remotes {
    sftpServer {
        host = sftpUrlSogis
        user = sftpUserSogis
        password = sftpPwdSogis
    }
}

//-----------

tasks.register('geoDoppelteSchemas', SqlExecutor) {
    database = [dbUriDuckDB, "", ""] // mit GRETL 3.1 nicht mehr nötig.
    sqlFiles = ["geo_doppelte_schemas.sql"]
    sqlParameters = [
        connectionStringPub : dbConnectionStringPub as String,
        connectionStringEdit : dbConnectionStringEdit as String
        ]
}

//-----------

tasks.register('simiSchemaOhneTabelle', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_schema_ohne_tabelle.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('simiRasterOhneDatesetView', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_raster_ohne_datasetview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('simiTableOhneTableView', SqlExecutor) {
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simi_table_ohne_tableview.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('listSftpDirectories') {
    doLast {
        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def dirs = ls("./gretl")
                        .findAll({ !(it.filename in ['.', '..']) 
                            && !it.filename.startsWith('.') 
                            && !it.filename.startsWith('robots')
                            && !it.filename.startsWith('nutzungsbedingungen')})
                        .collect({ it.filename }).sort()

                    File lstFile = new File('/tmp/sftpDirectoriesList.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        dirs.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('diffKennungSimiDatenabgabe', SqlExecutor) {
    dependsOn 'listSftpDirectories'
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["diff_kennung_simi_datenabgabe.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

//-----------

tasks.register('relationalThemePublicationCsv', SqlExecutor) {
    description 'Schreibt all vorhandenen Edit-Modell-Themenpublikationen (aka relational) in eine CSV-Datei.'
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["relational_theme_publication_csv.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('superflousPublicationFormatsCsv') {
    description 'Durchsucht anhand der CSV-Datei die Ordner nach shp, gpkg und dxf-Dateien und schreibt das Thema in eine CSV-Datei falls gefunden werden.'
    dependsOn 'relationalThemePublicationCsv'
    doLast {
        def themePublications = new File('/tmp/relational_theme_publication_csv.csv').text.readLines()
        //println themePublications

        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    def themesWithSuperflousFormats = []
                    themePublications.each { themeDir ->
                        def files = ls("./gretl/$themeDir/aktuell")
                            .findAll({ !(it.filename in ['.', '..', 'meta'])
                                && (
                                    it.filename.contains('xtf') // TODO gpkg
                                    || it.filename.contains('shp')
                                    || it.filename.contains('dxf')
                                )
                            })
                            .collect({ it.filename }).sort()

                        if (files.size() > 0) {
                            themesWithSuperflousFormats.add(themeDir)
                        }
                    }
                    File lstFile = new File('/tmp/qmbetrieb/superflous_publication_formats.csv')
                    lstFile.withWriter{ out ->
                        out.println('kennung')
                        themesWithSuperflousFormats.each {out.println it}
                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('relationalThemePublicationXlsx', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'superflousPublicationFormatsCsv'
    csvFile = file("/tmp/qmbetrieb/superflous_publication_formats.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputDir = file(outputFolder);
}

//-----------

tasks.register('simpleThemePublicationCsv', SqlExecutor) {
    description 'Schreibt all vorhandenen Pub-Modell-Themenpublikationen in eine CSV-Datei.'
    database = [dbUriDuckDB, "", ""]
    sqlFiles = ["simple_theme_publication_csv.sql"]
    sqlParameters = [
        connectionStringSimi : dbConnectionStringSimi as String
        ]
}

tasks.register('countSimplePublicationFormatsCsv') {
    description 'Durchsucht anhand der CSV-Datei die Ordner nach xtf, shp, gpkg und dxf-Dateien und schreibt die jeweilige Anzahl und das Thema in eine CSV-Datei. Es kann vorkommen, dass die Anzahl falsch ist, weil falsche Daten im Ordner liegen. Darum ist es mehr als bloss _missing formats_.'
    dependsOn 'simpleThemePublicationCsv'
    doLast {
        def themePublications = new File('/tmp/simple_theme_publication_csv.csv').text.readLines()
        //println themePublications

        ssh.run {
            session(remotes.sftpServer) {
                sftp {
                    File lstFile = new File('/tmp/qmbetrieb/count_simple_publication_formats.csv')
                    lstFile.withWriter{ out ->
                        out.print('kennung;xtf;gpkg;shp;dxf')
                    }

                    themePublications.each { themeDir ->
                        def xtfFiles = ls("./gretl/$themeDir/aktuell/*.xtf.zip")
                        def gpkgFiles = ls("./gretl/$themeDir/aktuell/*.gpkg.zip")
                        def shpFiles = ls("./gretl/$themeDir/aktuell/*.shp.zip")
                        def dxfFiles = ls("./gretl/$themeDir/aktuell/*.dxf.zip")

                        lstFile << "\n" << "$themeDir;$xtfFiles.size;$gpkgFiles.size;$shpFiles.size;$dxfFiles.size"

                    }
                    println "File listing saved to: ${lstFile.absolutePath}"
                } 
            }
        }
    }
}

tasks.register('countSimplePublicationFormatsXlsx', Csv2Excel) {
    description 'Wandelt CSV in eine Excel-Datei um.'
    dependsOn 'countSimplePublicationFormatsCsv'
    csvFile = file("/tmp/qmbetrieb/count_simple_publication_formats.csv")
    firstLineIsHeader = true
    valueDelimiter = null
    valueSeparator = ";"
    outputDir = file(outputFolder);
}

//-----------

tasks.register('validationTasks') {
    description 'Führt sämtliche Validierungstasks aus.'
    dependsOn 'geoDoppelteSchemas',
        'simiSchemaOhneTabelle',
        'simiRasterOhneDatesetView',
        'simiTableOhneTableView',
        'diffKennungSimiDatenabgabe',
        'relationalThemePublicationXlsx',
        'countSimplePublicationFormatsXlsx'
}

//-----------

tasks.register('zipXlsx', Zip) {
    dependsOn 'validationTasks'
    archiveFileName = "qmbetrieb.zip"
    //destinationDirectory = file(outputFolder)
    destinationDirectory = file(".")
    
    from(outputFolder) {
        include("**/*.xlsx", "**/*.csv")
    }
}

tasks.register('csv2duckdb', SqlExecutor) {
    dependsOn zipXlsx
    description 'Importiert alle CSV in eine neue DuckDB-Datenbank.'
    database = [dbUriResultDB, "", ""]
    sqlFiles = ["import_csv_to_duckdb.sql"]
}

tasks.register('uploadToExoscale', S3Upload) {
    dependsOn 'csv2duckdb'
    accessKey = exoAccessKeyAgi
    secretKey = exoSecretAccessKeyAgi
    sourceFile = outputResultDB
    endPoint = "https://sos-ch-dk-2.exo.io"
    region = "ch-dk-2"
    bucketName = 'ch.so.agi.fubar1'
    acl = "public-read"
}



// TODO:
// - Schema ohne Themenpublikation?
